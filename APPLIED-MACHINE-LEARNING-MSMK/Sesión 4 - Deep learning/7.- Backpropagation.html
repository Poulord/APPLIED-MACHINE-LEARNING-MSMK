<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizaci√≥n 3D de Retropropagaci√≥n (Descenso por Gradiente)</title>
    <!-- Carga Tailwind CSS para estilos modernos y responsivos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Carga Three.js para la renderizaci√≥n 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Carga OrbitControls para permitir al usuario rotar la escena -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* Personalizaci√≥n de la fuente Inter */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc;
        }
        /* Asegura que el contenedor de la escena 3D y el gr√°fico 2D compartan altura */
        .viz-container {
            height: 500px;
            width: 100%;
        }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div class="max-w-6xl mx-auto bg-white rounded-xl shadow-2xl p-6 md:p-10">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-teal-700 mb-4 text-center">
            Retropropagaci√≥n y el Descenso por Gradiente (3D)
        </h1>
        <p class="text-gray-600 mb-6 text-center">
            La Retropropagaci√≥n (Backpropagation) calcula las pendientes. El Descenso por Gradiente usa esas pendientes para actualizar los pesos.
        </p>

        <!-- Contenedores de Visualizaci√≥n 3D y 2D (Side-by-side en escritorio) -->
        <div class="flex flex-col lg:flex-row gap-6 mb-6">
            <!-- Contenedor para la visualizaci√≥n 3D -->
            <div class="lg:w-1/2 w-full rounded-lg overflow-hidden border-4 border-teal-500 bg-gray-100 viz-container">
                <div id="scene-container" class="w-full h-full">
                    <!-- El canvas de Three.js se insertar√° aqu√≠ -->
                </div>
            </div>

            <!-- Contenedor para la Gr√°fica de P√©rdida 2D -->
            <div class="lg:w-1/2 w-full rounded-lg border-4 border-indigo-500 bg-gray-100 viz-container p-2 flex flex-col">
                <h3 class="text-lg font-bold text-indigo-700 mb-1 text-center">
                    Curva de Entrenamiento (P√©rdida vs. Iteraci√≥n)
                </h3>
                <canvas id="loss-plot-canvas" class="flex-grow bg-white rounded-md"></canvas>
            </div>
        </div>

        <!-- NUEVO: Panel de Interpretaci√≥n de Ajuste (FIT) -->
        <div class="w-full rounded-xl border-4 border-orange-500 bg-gray-100 viz-container p-2 flex flex-col mb-6">
            <h3 class="text-lg font-bold text-orange-700 mb-1 text-center">
                Interpretaci√≥n de Ajuste (Fit): P√©rdida vs. Error
            </h3>
            <p class="text-xs text-center text-gray-500 mb-2">
                La distancia del punto a la curva (el error) disminuye conforme la P√©rdida 3D se reduce.
            </p>
            <canvas id="fit-plot-canvas" class="flex-grow bg-white rounded-md"></canvas>
        </div>

        <!-- Controles y Estado -->
        <div class="mt-6 p-4 bg-gray-50 rounded-xl shadow-inner">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">Control de Hiperpar√°metros</h2>
            
            <!-- Control del Learning Rate -->
            <div class="mb-4">
                <label for="learning-rate-slider" class="block text-sm font-medium text-gray-700">
                    Tasa de Aprendizaje (Learning Rate): <span id="learning-rate-value" class="font-bold text-indigo-600">0.010</span>
                </label>
                <input type="range" id="learning-rate-slider" min="0.005" max="0.1" step="0.005" value="0.01" class="w-full h-2 bg-indigo-200 rounded-lg appearance-none cursor-pointer mt-1">
                <div class="flex justify-between text-xs text-gray-500 mt-1">
                    <span>Lento (0.005)</span>
                    <span>R√°pido (0.1)</span>
                </div>
            </div>

            <div class="flex flex-col sm:flex-row justify-center items-center space-y-3 sm:space-y-0 sm:space-x-4">
                <button id="iniciar-descenso" class="w-full sm:w-auto bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">
                    ‚û°Ô∏è Iniciar Descenso (Paso 1)
                </button>
                <button id="reset-descenso" class="w-full sm:w-auto bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 transform hover:scale-105">
                    üîÑ Reiniciar Simulaci√≥n
                </button>
                <div class="text-lg font-medium text-gray-700 sm:w-auto w-full text-center sm:text-left">
                    <span id="estado-descenso" class="font-semibold text-red-500">Esperando...</span>
                </div>
            </div>
        </div>

        <div class="mt-8 pt-6 border-t border-gray-200">
            <h2 class="text-2xl font-bold text-teal-700 mb-4">
                Interpretaci√≥n de la Gr√°fica
            </h2>
            <ul class="list-disc list-inside space-y-3 text-gray-700">
                <li>
                    <span class="font-bold text-indigo-600">Tasa de Aprendizaje (Learning Rate):</span>
                    Controla la longitud del paso que da la bola. Un valor alto puede hacer que la bola <span class="font-bold">salte</span> el m√≠nimo o diverja. Un valor bajo la hace ir <span class="font-bold">lenta</span> pero con m√°s precisi√≥n.
                </li>
                <li>
                    <span class="font-bold text-red-500">La Bola/Puntos en 2D:</span>
                    Representan los <span class="font-bold">Pesos</span> (Weights) actuales de la red neuronal. La posici√≥n en la gr√°fica 2D muestra la <span class="font-bold">P√©rdida</span> asociada a esos pesos.
                </li>
                <li>
                    <span class="font-bold text-green-600">El Movimiento:</span>
                    Simula el <span class="font-bold">Descenso por Gradiente</span>. La bola siempre "rueda" en la direcci√≥n opuesta al <span class="font-bold">Gradiente</span>, para encontrar un valor de p√©rdida m√°s bajo.
                </li>
                <li>
                    <span class="font-bold text-orange-500">M√≠nimos Locales:</span>
                    Son los valles poco profundos. Si la bola queda atrapada en uno, el modelo deja de aprender, aunque no haya encontrado el mejor resultado (M√≠nimo Global).
                </li>
            </ul>
        </div>
    </div>

    <script>
        // Variables globales de Three.js
        let scene, camera, renderer, surface, ball, controls;
        let iteration = 0;
        let isConverged = false;
        
        // Variables de la gr√°fica 2D
        let lossPlotCanvas, lossPlotContext;
        let lossHistory = [];
        const MAX_LOSS = 30; // Valor m√°ximo aproximado de la p√©rdida en la superficie 3D
        
        // Variables de la gr√°fica de Ajuste (Fit) - NUEVAS
        let fitPlotCanvas, fitPlotContext;
        let fitDataPoints = []; // Almacena {x, loss, iteration}
        const FIT_RANGE = 100; // Escala de 0 a 100 para los ejes X/Y de esta gr√°fica
        const FIT_CURVE_SCALE = 0.02; 

        // Tasa de aprendizaje inicializada din√°micamente
        let learningRate = parseFloat(document.getElementById('learning-rate-slider').value);
        const MIN_CLICKS_FOR_CONVERGENCE = 7; // Requisito del usuario

        const container = document.getElementById('scene-container');
        const estadoDescenso = document.getElementById('estado-descenso');
        const botonDescenso = document.getElementById('iniciar-descenso');
        const botonReset = document.getElementById('reset-descenso');
        const lrSlider = document.getElementById('learning-rate-slider');
        const lrValueDisplay = document.getElementById('learning-rate-value');
        
        // Funciones de utilidad
        function lossFunction(x, y) {
            const nx = x / 10;
            const ny = y / 10;
            // Componente parab√≥lica (siempre >= 0)
            const quadratic = (nx * nx + ny * ny) * 5;
            // Componente sinusoidal para crear valles (m√≠nimos locales)
            const sinusoidal = Math.sin(nx * 8) * 1.5 + Math.cos(ny * 8) * 1.5;
            // Desplazamiento de +1 para asegurar que la p√©rdida (Z) sea siempre positiva.
            const offset = 1; 
            const Z = quadratic + sinusoidal + offset;
            return Z;
        }

        function calculateGradient(x, y, h = 0.001) {
            const dX = (lossFunction(x + h, y) - lossFunction(x - h, y)) / (2 * h);
            const dY = (lossFunction(x, y + h) - lossFunction(x, y - h)) / (2 * h);
            return { dx: dX, dy: dY };
        }

        // --- L√≥gica de la Gr√°fica 2D de P√©rdida (Loss) ---
        function init2DPlot() {
            lossPlotCanvas = document.getElementById('loss-plot-canvas');
            lossPlotContext = lossPlotCanvas.getContext('2d');
            
            // Ajustar el tama√±o del canvas al contenedor (importante para alta resoluci√≥n)
            lossPlotCanvas.width = lossPlotCanvas.clientWidth;
            lossPlotCanvas.height = lossPlotCanvas.clientHeight;
            
            draw2DPlot(); // Dibujar el estado inicial (ejes)
        }

        function draw2DPlot() {
            if (!lossPlotContext) return;
            
            const ctx = lossPlotContext;
            const W = lossPlotCanvas.width;
            const H = lossPlotCanvas.height;
            const padding = 40;

            // Limpiar y fondo
            ctx.clearRect(0, 0, W, H);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, W, H);

            // Escalas
            const maxIterations = Math.max(iteration, MIN_CLICKS_FOR_CONVERGENCE + 2);
            const scaleX = (W - padding * 2) / maxIterations;
            const scaleY = (H - padding * 2) / MAX_LOSS; // Mapear p√©rdida a altura

            // Dibujar Ejes
            ctx.strokeStyle = '#374151'; // Gris oscuro
            ctx.lineWidth = 1;
            
            // Eje Y (P√©rdida)
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, H - padding);
            ctx.stroke();
            
            // Eje X (Iteraci√≥n)
            ctx.beginPath();
            ctx.moveTo(padding, H - padding);
            ctx.lineTo(W - padding, H - padding);
            ctx.stroke();
            
            // Etiquetas de Ejes
            ctx.fillStyle = '#374151';
            ctx.font = '12px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Iteraci√≥n', W / 2, H - 5);
            ctx.textAlign = 'right';
            ctx.save();
            ctx.translate(10, H / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('P√©rdida (Loss)', 0, 0);
            ctx.restore();

            // Dibujar Puntos y L√≠nea de P√©rdida
            if (lossHistory.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = '#6366f1'; // Color √çndigo
                ctx.lineWidth = 2;
                
                // Mover al primer punto
                const x0 = padding;
                const y0 = H - padding - lossHistory[0] * scaleY;
                ctx.moveTo(x0, y0);
                
                // Dibujar l√≠nea y puntos
                lossHistory.forEach((loss, index) => {
                    const x = padding + (index + 1) * scaleX;
                    const y = H - padding - loss * scaleY;

                    // Dibujar l√≠nea
                    ctx.lineTo(x, y);

                    // Dibujar punto (c√≠rculo)
                    ctx.fillStyle = '#ef4444'; // Rojo (Error)
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2, true);
                    ctx.fill();
                    
                    // Etiqueta del √∫ltimo punto
                    if (index === lossHistory.length - 1) {
                        ctx.fillStyle = '#10b981'; // Verde (Convergencia)
                        ctx.font = '10px Inter, sans-serif';
                        ctx.textAlign = 'left';
                        ctx.fillText(`L: ${loss.toFixed(2)}`, x + 5, y - 5);
                    }
                });
                ctx.stroke();
            }
        }
        // --- Fin L√≥gica de la Gr√°fica 2D de P√©rdida (Loss) ---

        // --- L√≥gica de la Gr√°fica de Ajuste (Fit) - NUEVA ---
        function initFitPlot() {
            fitPlotCanvas = document.getElementById('fit-plot-canvas');
            fitPlotContext = fitPlotCanvas.getContext('2d');
            
            fitPlotCanvas.width = fitPlotCanvas.clientWidth;
            fitPlotCanvas.height = fitPlotCanvas.clientHeight;
            
            fitDataPoints = [];
            drawFitPlot();
        }

        // Funci√≥n Par√°bola (Representa la Predicci√≥n del Modelo, escalado 0-100)
        function parabola(x) {
            // Curva: Y = 0.02 * (X - 50)^2 + 10. M√≠nimo en X=50, Y=10.
            return FIT_CURVE_SCALE * (x - 50) * (x - 50) + 10;
        }

        function drawFitPlot() {
            if (!fitPlotContext) return;
            
            const ctx = fitPlotContext;
            const W = fitPlotCanvas.width;
            const H = fitPlotCanvas.height;
            const padding = 20;

            // Limpiar y fondo
            ctx.clearRect(0, 0, W, H);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, W, H);

            // Escalas (Mapeo de 0-100 al canvas)
            const scaleX = (W - padding * 2) / FIT_RANGE;
            const scaleY = (H - padding * 2) / FIT_RANGE;

            // Dibujar la curva (Modelo)
            ctx.beginPath();
            ctx.strokeStyle = '#f97316'; // Naranja (Modelo)
            ctx.lineWidth = 3;
            // Mover al primer punto (X=0)
            ctx.moveTo(padding, H - padding - parabola(0) * scaleY); 
            for (let x = 0; x <= FIT_RANGE; x++) {
                const px = padding + x * scaleX;
                const py = H - padding - parabola(x) * scaleY;
                ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Dibujar Puntos de Datos (Representan el Error)
            fitDataPoints.forEach(point => {
                const px = padding + point.x * scaleX;
                // Posici√≥n base en la par√°bola (Predicci√≥n)
                const pyTarget = H - padding - parabola(point.x) * scaleY;

                // Mapear p√©rdida a desplazamiento vertical (Error)
                const maxLossValue = MAX_LOSS; 
                const minLossValue = 1; // M√≠nimo de p√©rdida con el offset=1
                
                // Normalizar la p√©rdida (0 a 1)
                const normalizedLoss = (point.loss - minLossValue) / (maxLossValue - minLossValue);
                
                // Escalar el desplazamiento, m√°ximo desplazamiento es 40 unidades en la escala Y
                const maxDisplacementY = 40 * scaleY; 
                
                // Desplazamiento real (el error)
                let displacement = normalizedLoss * maxDisplacementY;
                
                // Alternar si el punto est√° por encima o por debajo de la curva
                const sign = (point.iteration % 2 === 0) ? -1 : 1; 
                
                const py = pyTarget + sign * displacement;

                // Dibujar punto (Data Point)
                ctx.fillStyle = '#10b981'; // Verde (Data)
                ctx.beginPath();
                ctx.arc(px, py, 5, 0, Math.PI * 2, true);
                ctx.fill();

                // Dibujar l√≠nea de error
                ctx.strokeStyle = '#ef4444'; // Rojo (Error Line)
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(px, pyTarget);
                ctx.stroke();
            });
        }
        
        function updateFitPlot(currentLoss) {
            // Generar un nuevo punto X aleatorio 
            const randomX = Math.random() * FIT_RANGE;
            
            fitDataPoints.push({
                x: randomX,
                loss: currentLoss,
                iteration: iteration // Usamos la iteraci√≥n para el signo del desplazamiento
            });
            
            // Mantener solo los √∫ltimos 20 puntos para no saturar la gr√°fica
            if (fitDataPoints.length > 20) {
                fitDataPoints.shift();
            }
            
            drawFitPlot();
        }
        // --- Fin L√≥gica de la Gr√°fica de Ajuste (Fit) ---


        function initScene() {
            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xecf0f1);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 4. Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(20, 30, 10);
            scene.add(directionalLight);
            
            // 5. Orbit Controls
            if (typeof THREE.OrbitControls !== 'undefined') {
                 controls = new THREE.OrbitControls(camera, renderer.domElement);
                 controls.enableDamping = true;
                 controls.dampingFactor = 0.05;
                 controls.minDistance = 5;
                 controls.maxDistance = 50;
            }

            // 6. Create Surface
            createSurface();

            // 7. Create Ball
            createBall();
            
            // 8. Inicializar Gr√°fica 2D de P√©rdida
            init2DPlot();
            // 8b. Inicializar Gr√°fica de Ajuste
            initFitPlot();


            // 9. Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            botonDescenso.addEventListener('click', handleButtonClick);
            botonReset.addEventListener('click', resetDescent);
            lrSlider.addEventListener('input', handleLearningRateChange); 

            // 10. Start Animation Loop
            animate();
            renderer.render(scene, camera); 
        }
        
        function handleLearningRateChange(event) {
            learningRate = parseFloat(event.target.value);
            lrValueDisplay.textContent = learningRate.toFixed(3);
            
            if (!isConverged && iteration > 0) {
                 resetDescent();
            }
        }

        function createSurface() {
            const SIZE = 20;
            const SEGMENTS = 80;

            const geometry = new THREE.PlaneGeometry(SIZE, SIZE, SEGMENTS, SEGMENTS);
            const material = new THREE.MeshPhongMaterial({
                color: 0x00897b,
                wireframe: false,
                side: THREE.DoubleSide,
                shininess: 30
            });

            const positionAttribute = geometry.attributes.position;
            for (let i = 0; i < positionAttribute.count; i++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);
                const z = lossFunction(x, y);
                positionAttribute.setZ(i, z);
            }
            geometry.computeVertexNormals();
            positionAttribute.needsUpdate = true; 

            surface = new THREE.Mesh(geometry, material);
            surface.rotation.x = -Math.PI / 2;
            surface.position.y = 0;

            scene.add(surface);
        }

        function createBall() {
            const startX = 8;
            const startY = -8;
            const startZ = lossFunction(startX, startY) + 0.5;

            const geometry = new THREE.SphereGeometry(0.5, 32, 32);
            const material = new THREE.MeshPhongMaterial({ color: 0xe74c3c, shininess: 100 });
            
            if (ball) {
                scene.remove(ball);
            }
            ball = new THREE.Mesh(geometry, material);

            ball.position.set(startX, startZ, startY); 
            
            // Registrar la p√©rdida inicial
            lossHistory = [];
            lossHistory.push(lossFunction(startX, startY));
            draw2DPlot();
            
            scene.add(ball);
        }
        
        function stepDescent() {
            if (isConverged) return;

            iteration++;
            
            const currentX = ball.position.x;
            const currentY = ball.position.z;

            // 2. Calcular el Gradiente (Retropropagaci√≥n)
            const gradient = calculateGradient(currentX, currentY);

            // 3. Actualizar la posici√≥n (Descenso por Gradiente)
            let newX = currentX - learningRate * gradient.dx;
            let newY = currentY - learningRate * gradient.dy;
            
            // 4. Calcular la nueva altura (P√©rdida) y actualizar la bola
            const newLoss = lossFunction(newX, newY);
            const newZ = newLoss + 0.5;
            
            // Guardar en el historial para la gr√°fica 2D de P√©rdida
            lossHistory.push(newLoss);

            ball.position.x = newX;
            ball.position.z = newY;
            ball.position.y = newZ;
            
            // Actualizar gr√°fica 2D
            draw2DPlot();
            // Actualizar gr√°fica de ajuste (NUEVO)
            updateFitPlot(newLoss);


            // 5. Condici√≥n de parada: M√≠nimo de 7 iteraciones Y gradiente peque√±o.
            const gradientMagnitude = Math.sqrt(gradient.dx * gradient.dx + gradient.dy * gradient.dy);
            
            if (iteration >= MIN_CLICKS_FOR_CONVERGENCE && gradientMagnitude < 0.01) {
                isConverged = true;
                estadoDescenso.textContent = `¬°Convergido en ${iteration} pasos! (P√©rdida: ${newLoss.toFixed(2)})`;
                estadoDescenso.className = 'font-semibold text-green-600';
                botonDescenso.textContent = '‚úÖ Convergido';
                botonDescenso.disabled = true;
            } else {
                estadoDescenso.textContent = `Paso ${iteration}. P√©rdida: ${newLoss.toFixed(2)}`;
                estadoDescenso.className = 'font-semibold text-blue-600';
                botonDescenso.textContent = `‚û°Ô∏è Siguiente Paso (${iteration + 1})`;
            }
            
            renderer.render(scene, camera);
        }

        function resetDescent() {
            isConverged = false;
            iteration = 0;
            createBall(); // Esto tambi√©n reinicia lossHistory y llama a draw2DPlot
            fitDataPoints = []; // Reiniciar puntos de ajuste
            drawFitPlot(); // Redibujar gr√°fica de ajuste
            estadoDescenso.textContent = 'Esperando...';
            estadoDescenso.className = 'font-semibold text-red-500';
            botonDescenso.textContent = '‚û°Ô∏è Iniciar Descenso (Paso 1)';
            botonDescenso.disabled = false;
            renderer.render(scene, camera); 
        }

        function handleButtonClick() {
            if (!isConverged) {
                stepDescent();
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls) {
                controls.update();
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            // Actualizar 3D
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);

            // Actualizar 2D Loss Plot
            if (lossPlotCanvas) {
                lossPlotCanvas.width = lossPlotCanvas.clientWidth;
                lossPlotCanvas.height = lossPlotCanvas.clientHeight;
                draw2DPlot();
            }
            
            // Actualizar 2D Fit Plot (NUEVO)
            if (fitPlotCanvas) {
                fitPlotCanvas.width = fitPlotCanvas.clientWidth;
                fitPlotCanvas.height = fitPlotCanvas.clientHeight;
                drawFitPlot();
            }
        }

        window.onload = initScene;
    </script>
</body>
</html>

